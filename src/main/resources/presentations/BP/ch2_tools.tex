\section{Tool Selection and Technology Stack}\label{sec:tools}

This chapter examines the decision-making process behind selecting the technologies and tools for the team-work organization system.
The selection criteria were based on several key factors: project requirements, scalability needs, security considerations, and long-term maintainability.

\subsection{Framework Selection}\label{subsec:framework-selection}

Given the project's requirement to develop a Java application, the framework selection was focused on Java-based solutions.
The primary options considered were \textit{The Spring Framework}, \textit{Spring Boot},  \textit{Jakarta EE} (formerly Java EE), and \textit{Micronaut}.
Although all of these frameworks are capable of building robust web applications, they differ significantly in their approach and complexity.

\textbf{Jakarta EE}, the enterprise edition of Java, provides a comprehensive set of specifications to build enterprise applications.
However, it requires significant boilerplate code and configuration, making it less suitable for this project.
\textbf{Micronaut}, while promising with its ahead-of-time compilation and low memory footprint, is relatively new and has a smaller community compared to Spring Boot.

\textbf{The Spring Framework}, the foundation of Spring Boot, is a comprehensive programming and configuration model for modern Java-based enterprise applications.
It provides a wide range of features including dependency injection, aspect-oriented programming, and transaction management.
However, the Spring Framework requires extensive configuration and setup, which can be time consuming and complex.

\textbf{Spring Boot}, built on top of the Spring Framework, was selected as it addresses these configuration challenges while maintaining all the benefits of the Spring Framework.
It provides the following:
\begin{itemize}
    \item Auto-configuration of Spring Framework components
    \item Embedded servers for simplified deployment
    \item Production-ready features like metrics and health checks
    \item Reduced boilerplate code and configuration
\end{itemize}

This combination of Spring Framework's robust features and Spring Boot's simplified development approach makes it ideal for this project.
The framework's extensive documentation, large community support, and proven track record in enterprise applications further reinforce this choice.

\subsection{Frontend Technology Selection}\label{subsec:frontend-selection}

The selection of front-end technology required careful consideration of integration capabilities with Spring Boot.
\textbf{Thymeleaf}, as a server-side template rendering engine, was identified as the preferred option due to several factors. It utilizes server-side page rendering to decrease the computational load on client systems. Its integration of Java with HTML makes it relatively straightforward to use. Furthermore, it is frequently used in conjunction with the Spring Boot.
Although modern alternatives like \textbf{React} and other JavaScript frameworks are prevalent, they would require significant additional research and development time.

The decision to use Thymeleaf was influenced by the simplicity of combining HTML and Java code in a single file.
However, modern web development requirements necessitated the incorporation of some JavaScript for specific client-side tasks, particularly for handling asynchronous requests and dynamic content updates.

\subsection{Database Selection}\label{subsec:database-selection}

\textbf{PostgreSQL} was selected as the primary database system after evaluating various database options, including NoSQL alternatives.
This choice was driven by PostgreSQL's prevalence in the market and its robust ACID compliance, which ensures data integrity and reliability.
The ACID properties provide essential guarantees for data management:

\begin{itemize}
    \item \textbf{Atomicity}: Ensures transactions are completed entirely or not at all.
    \item \textbf{Consistency}: Maintains database validity through all transactions.
    \item \textbf{Isolation}: Prevents concurrent transactions from interfering with each other.
    \item \textbf{Durability}: Guarantees committed transactions remain permanent.
\end{itemize}

These properties are crucial for maintaining data integrity in a multi-user environment where concurrent access and modifications are common.

\subsection{Security Architecture Decisions}\label{subsec:security-decisions}

The security implementation strategy was developed after careful analysis of the security requirements of modern web applications.
The decision to use \textbf{JWT-based authentication} was made after considering several factors, including the benefits of a stateless architecture that eliminates server-side session storage and improves scalability.
The approach also offers excellent cross-platform compatibility, enabling seamless integration with various clients while maintaining compliance with industry best practices for web security.
Alternative approaches like \textbf{session-based authentication} were evaluated but rejected due to their increased complexity with server-side session storage, increased server resource requirements, and complex session management.


The main security framework used is \textbf{Spring Security}, which provides a comprehensive security solution for Spring-based applications.
Although it is a powerful framework, it is not without its own challenges, such as the need to configure multiple security components and the potential for increased complexity in the codebase.
Still, the benefits of using a well-established security framework benefits the project in the long run.

\subsection{Development Tool Selection}\label{subsec:tool-selection}

The choice of development tools was guided by the need to improve code quality and development efficiency.
\textbf{Lombok} was selected because it effectively reduces boilerplate code without runtime overhead, integrates seamlessly with existing IDEs, and maintains code readability while reducing verbosity.
The IDE used is \textbf{IntelliJ IDEA}, which has excellent support for Java.

\subsection{Containerization Strategy}\label{subsec:containerization}

Containerization was implemented using \textbf{Docker} to ensure consistent deployment across different environments and simplify the development workflow.
The containerization strategy employs a multi-stage build process that optimizes both build time and final image size.
The build process utilizes \textbf{Amazon Corretto JDK 21} to compile the application and run it in a separate dockerfile stage.
The system includes integrated health checks to monitor container status, ensuring reliable operation and quick detection of potential problems.

This containerization approach delivers significant benefits to the project.
It ensures a consistent runtime environment across development, testing, and production stages, eliminating environment-specific issues.
The deployment process is simplified, reducing the complexity of moving the application between different environments.
Container isolation provides an additional layer of security, while the standardized container format enables easy scalability and orchestration capabilities.
Furthermore, this approach effectively eliminates the common ``works on my machine'' problem, as all environments run the same containerized application.
The basics of this approach were learned from the video resource~\cite{LearnDocker}.

\subsection{Technology Stack Integration}\label{subsec:integration}

The selected technologies were tested for their ability to work together.
The integration strategy focused on ensuring compatibility between all components, maintaining optimal system performance across all layers, and creating a system that can be easily updated and modified.
This careful selection and integration of technologies has resulted in a robust, scalable, and maintainable system that meets project requirements while providing a solid foundation for future enhancements.

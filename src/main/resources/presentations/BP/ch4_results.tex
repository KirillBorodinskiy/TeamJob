\section{Calendar Interface and Rendering}\label{sec:calendar-interface-and-rendering}
The calendar is the primary interface of the application, implemented through an integration of Thymeleaf templates and JavaScript to enhance interactivity.
The underlying backend functionality is administered by the CalendarController and CalendarServiceImpl service.
Upon users' access to the calendar, the controller delegates service methods such as setupModelForWeekCalendar and setupModelForDayCalendar to the responsibility of preparing the required data for the rendering of weekly or daily views.
These methods retrieve all pertinent events from the database, filter them according to user, room, and tag parameters, and structure them into entities such as WeekDay and EventInADay.
The filtration process is thorough, accommodating combinations of user IDs, room IDs, and tags, and is implemented in the service layer through the use of helper methods that parse and apply these filters.
Subsequently, the calendar view is rendered by Thymeleaf, which receives all data as model attributes, while JavaScript is employed to augment navigation and interactivity, easing shifts between weeks or days.


\section{Event Creation, Validation, and Conflict Detection}\label{sec:event-creation-validation-and-conflict-detection}
The creation of events is managed through REST endpoints within the RestConfigController.
Upon submission of a new event by the user, the backend initiates a check for scheduling conflicts employing the findOverlappingEventsInRoom method of the EventRepository.
This mechanism ensures that no two events simultaneously occupy the same room.
In instances where a scheduling conflict is identified, the system issues a conflict response, requiring the user to select an alternative time or resource.
The event creation process accommodates both singular and recurring events.
For recurring events, the system constructs an RRULE string that complies with RFC 5545 standards, including support for intervals, end dates, and specific weekdays in the case of weekly recurrences.
The event entity is responsible for maintaining all recurrence-related information, including exception dates (exdate) and supplementary dates (rdate).
While the backend logic for recurring events is fully implemented and functional, the frontend display of recurring events in the calendar interface has not been completed.
The system successfully stores and processes recurring event data, but the visual representation of these events in the calendar views requires further development.
In addition, the DefaultValueService has been implemented to facilitate the demonstration of the project.
It generates test events, users, and rooms to verify the system's functionality under conditions of load.


\section{Filtering by User, Room, and Tags}\label{sec:filtering-by-user-room-and-tags}
The capability to filter is a fundamental aspect of the calendar and event views.
The backend enables the filtration of events based on user IDs, room IDs, and tags associated with users, rooms, or events.
This functionality is executed in the CalendarServiceImpl service, where methods such as convertToDayEvents and generateAvailableTimeRequest implement filters on the event list prior to rendering to the frontend.
The filtering mechanism interprets comma-delimited strings of IDs or tags, converts these into sets, and applies them to the event data using Java Streams and supporting techniques.
Consequently, events are excluded if their associated user, room, or tags do not correspond to the designated criteria.
This enables users to focus on the most relevant events, even in scenarios marked by a substantial number of planned activities.


\section{Authentication and Role-Based Access Control}\label{sec:authentication-and-role-based-access-control}
Authentication is achieved through the use of JWT (JSON Web Tokens), with the SecurityController overseeing the workflows of sign-in, sign-up, and sign-out.
The user credentials are subjected to secure hashing and storage, and the JWT tokens are distributed upon successful completion of authentication.
The TokenFilter plays a critical role in intercepting requests, extracting and validating JWT tokens, and establishing the security context for the authenticated user.

Role-based access control is enforced throughout the application.
Users are assigned specific roles such as ROLE\_USER, ROLE\_ADMIN, or ROLE\_CONFIG, which are stored within the database and linked to each user.
The SecurityConfigurator utilizes Spring Security to impose access restrictions on sensitive endpoints that depend on these roles.
For instance, only users possessing roles of ROLE\_CONFIG or ROLE\_ADMIN are authorized to create, edit, or delete events and rooms, whereas regular users are restricted to activities like viewing and searching.
CSRF protection is systematically enabled for all forms.

The auditing part of the Spring Data framework\cite{AuditingSpringData} serves as a mechanism to monitor alterations to entities.
It records the timestamp of creation, identifies the creator, and documents the identity and timing of modifications within the database.
This framework facilitates the verification of the authorship of any modifications made within the system.


\section{Tagging System}\label{sec:tagging-system}
The application incorporates a robust tagging system applicable to users, rooms, and events.
Tags are maintained as collections of strings within each entity (User, Room, Event) and are stored in separate tables utilizing JPA's @ElementCollection.
Tags are employed extensively throughout the interface for the purposes of filtering and searching, and are also presented in both list and detailed views.
The backend includes methods to retrieve all unique tags from the database, which are subsequently displayed in dropdown menus and filter panels within the user interface.
Tag-based filtering is executed within the service layer, enabling users to efficiently access pertinent information by selecting one or more tags.
Furthermore, the system supports the allocation of random tags to entities during the generation of test data, thus ensuring a diverse array of tags for both demonstration and testing purposes.


\section{Error Handling and Custom Error Pages}\label{sec:errorHandlingAndCustomErrorPages}
The management of errors is facilitated by an error controller, referred to as the CustomErrorController, which intercepts errors and generates a comprehensive error page \texttt{error-debug.html}.
This controller is responsible for extracting error statuses, exception details, messages, and the pathways of requests, and it incorporates stack traces whenever they are available.
This methodology affords developers and administrators exhaustive information necessary for debugging and system maintenance, while concurrently supplying end users with lucid feedback regarding any issues encountered.


\section{Room and User Management}\label{sec:roomAndUserManagement}
The management of rooms and users is integrated into both backend and frontend systems.
The ConfigController offers endpoints for the enumeration, addition, and removal of rooms and users.
In the backend, there are strict verifications to ensure that only users with designated roles are authorized to carry out these operations.
The system performs checks to ensure uniqueness in identifiers such as room name, username, and email.

The frontend displays comprehensive lists of rooms and users, inclusive of their tags and roles, and provides forms for the entry of new data.
The deletion process is secured by the inclusion of confirmation prompts and backend verifications to avert the inadvertent removal of critical resources.
Additionally, the system accommodates the bulk management of events, rooms, and users, thereby enhancing the efficiency of administrative functions.


\section{Find Available Functionality}\label{sec:findAvailableFunctionality}
The ``Find Available'' functionality is executed within the CalendarController and CalendarServiceImpl.
Users are enabled to query for available rooms or users by specifying relevant tags, date, start, and end times, as well as the desired duration.
The backend systematically processes these inputs, computes unoccupied time slots using the generateAvailableTimeRequest method, and subsequently provides a list of available resources.
The returned results include direct links to observe availability within the calendar, thus significantly streamlining the scheduling of meetings or events in environments characterized by high demand for bookings.
This particular functionality is notably absent from the existing scheduling system implemented at my University.

\newpage
\section{Installation and Deployment tutorial}\label{sec:installationAndDeploymentTutorial}
The installation of this project was made simple and straightforward.

\textbf{Firstly, install docker.} This can be done either from the official website or from the package manager of your operating system.
For example, on Ubuntu, you can install docker using the following commands (From the official website~\cite{DockerWebsite}):
\begin{minted}{bash}
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

echo \
 "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
 $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
 sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin git
\end{minted}
This will install git, docker and docker-compose.

\textit{Note:} If you are using a different operating system, you can find the installation instructions on the official website.

\textbf{Secondly, clone the repository.} This will be done using git that was installed in the previous step.
\begin{minted}{bash}
git clone https://github.com/KirillBorodinskiy/TeamJob.git
\end{minted}

\textbf{Thirdly, build and run the project.} This will be done using docker-compose that was pre-configured to handle all tasks and dependencies automatically.
\begin{minted}{bash}
cd TeamJob
docker-compose up
\end{minted}

The application will be accessible through a web browser at \url{http://localhost:8080} upon successful deployment.
The default port configuration can be modified within the \texttt{docker-compose.yml} file to accommodate specific network requirements or port conflicts.
This containerized deployment approach ensures consistent execution environments across different operating systems and eliminates the need for manual dependency management.

For development and customization purposes, the application can be executed without Docker containerization, though this approach necessitates additional configuration and setup procedures.
This alternative deployment method requires the installation of Java Development Kit (JDK) version 21, which can be obtained from the official Oracle website or through package managers such as Homebrew on macOS or apt on Ubuntu systems.
The local execution process involves navigating to the project directory and utilizing the Gradle wrapper to compile and run the application:

\begin{minted}{bash}
cd TeamJob
./gradlew build
\end{minted}

This non-containerized approach requires manual configuration of the PostgreSQL database, including the establishment of database credentials, creation of the database instance, and configuration of connection parameters within the application properties.
Additionally, users must ensure that all required environment variables are properly set, including database connection strings, authentication secrets, and application-specific configurations.
This deployment method is particularly suitable for developers who require direct access to the application source code for customization, debugging, or integration with existing development workflows.

\newpage
\section{Usage tutorial}\label{sec:usageTutorial}
The application provides an intuitive and comprehensive user interface designed to facilitate efficient scheduling and resource management.
The system implements a multi-layered authentication mechanism and offers extensive functionality for calendar management, event creation, and administrative operations.

The authentication system utilizes JSON Web Tokens (JWT) to facilitate secure session management throughout the application.
User registration is allowed through multiple endpoints (\texttt{/signup} and \texttt{/register}), with authentication processes available via \texttt{/login}, \texttt{/signin}, and the primary endpoint \texttt{/}.
This redundant routing approach ensures ease of access regardless of the user's point of entry.
Following successful authentication, the system issues a cryptographically secure JWT token, which is retained in the browser's cookie storage, thereby providing persistent session management while upholding security through token expiration and validation.
The implementation includes comprehensive error handling mechanisms for invalid credentials and session expiration.

The primary calendar interface at \texttt{/calendar} functions as the central operational hub, allowing users to visualize, create, and manage events through an intuitive interface.
This interface accommodates both weekly and daily perspectives, allowing users to traverse different temporal views.
Detailed event information is accessible via the \texttt{/event/\{id\}} endpoint, which provides comprehensive data, including participant details, room allocations, and related metadata.
Information specific to rooms can be obtained through the \texttt{/room/\{id\}} endpoint, which provides extensive room specifications, availability patterns and organizational tags.

The centralization of administrative functionality is achieved via the hierarchy of the \texttt{/config} endpoint.
The \texttt{/config/rooms} endpoint provides capabilities for room management, facilitating administrators to view, create, and modify room configurations that include capacity specifications, equipment details, as well as organizational tags.
The \texttt{/config/events} endpoint provides event management functionality, including reviewing scheduled events, modifying event details, and managing event-specific metadata.
In addition, user management through \texttt{/config/users} grants administrative access to user account information, role assignments, and user-specific configurations.
This administrative interface supports role-based access control, allowing system administrators to allocate appropriate permissions and organizational roles.
The system employs comprehensive audit trails for all administrative operations, ensuring accountability and offering detailed logs for purposes related to security and compliance.

The \texttt{/calendar/findAvailable} endpoint enables the identification of available resources by allowing users to apply specific criteria such as temporal constraints, resource tags, and duration requirements.
This capability is particularly advantageous in contexts characterized by high resource contention, as it allows users to optimally identify appropriate time slots and resources.
In addition, the system offers extensive filtering capabilities, allowing users to concentrate on designated subsets of events and resources.
Users have the ability to filter calendar views based on user identifiers, room specifications, and organizational tags, creating personalized views that improve the salience of pertinent information while mitigating cognitive load.
The realization of this filtering functionality is facilitated through the integration of front-end interface controls alongside back-end query optimization processes; thus, it should maintain performance efficiency even while handling large datasets.
